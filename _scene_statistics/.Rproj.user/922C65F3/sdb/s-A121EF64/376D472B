{
    "collab_server" : "",
    "contents" : "simple.fit <- function(target = \"vertical\") {\n\n  human.responses <- get_human_responses()\n  human.responses <- human.responses %>% select(-L,-C, -S, -statType, -statValue) %>% distinct() %>%\n    filter(SUBJECT != \"sps\")\n\n  formatted.responses <- human.responses %>%\n    group_by(TARGET, BIN) %>%\n    nest() %>%\n    mutate(data = map(data, function(data) {format.response(data)})) %>%\n    arrange(TARGET, BIN) %>%\n    filter(TARGET == target)\n  \n    fit.separate <- formatted.responses %>%\n    mutate(full.model = map(data, function(data) {\n      f        <- curry::partial(f.NLL, list(d0 = 4.5, data = data))\n      class(f) <- \"function\" #stupid bbmle doesn't like the scaffold.\n\n      mle2(f, start = list(e0 = 5, b = 4, gamma = 0), \n           lower = c(e0 = .5, b = 0, gamma = -3),\n           upper = c(e0 = 40, b = 20, gamma = 3),\n           method = \"L-BFGS-B\") # let's party bbmle\n  })) %>%\n  mutate(d0 = 4.5) %>%\n  as_tibble()\n  \n  formatted.responses <- as_tibble(cbind(formatted.responses, data.frame(do.call(rbind, (map(fit.separate$full.model, coef))))))\n  #cluster_copy(cluster, formatted.responses)\n  \n  # Compute the negative log likelihood for individual level e0 nested within target b0 and overall d0\n  b.NLL <- function(b, bLikelihood = TRUE) {\n    \n    d0    <- 4.5\n    b     <- b\n    #b_v  <- params[2]\n    #b_h  <- params[3]\n    #b_b  <- params[4]\n    #b_s  <- params[5]\n    \n    formatted.responses$d0 <- NULL\n    formatted.responses$b  <- NULL\n    \n    formatted.responses$d0 <- d0\n    formatted.responses$b  <- b\n    #formatted.responses$b[formatted.responses$TARGET == \"vertical\"]   <- b\n    #formatted.responses$b[formatted.responses$TARGET == \"horizontal\"] <- b\n    #formatted.responses$b[formatted.responses$TARGET == \"bowtie\"]     <- b\n    #formatted.responses$b[formatted.responses$TARGET == \"spot\"]       <- b\n    \n    # Use currying to fix the beta for the beta level fit.\n    f.eval.list <- by_row(formatted.responses, function(data) {\n      f <- curry::partial(f.NLL, list(d0 = data$d0, b = data$b, data = data$data[[1]]))},\n      .to = 'f')\n    \n    start.list <- f.eval.list %>% group_by(BIN) %>% nest()\n    \n    min.vals <- mclapply(start.list$data, FUN = function(x) {\n      print(x)\n      f     <- x$f\n      e0    <- x$e0\n      gamma <- x$gamma\n      class(f) <- \"function\"\n      f\n      mle2(f, start = list(e0 = e0, gamma = gamma), method = \"L-BFGS-B\", lower = c(e0 = .5, gamma = -3), upper = c(e0 = 23, gamma = 3),\n      #     control = list(trace = 0))\n    }, mc.cores=n.cores)\n  \n    if (bLikelihood == TRUE) {\n      NLL <- Reduce('+', map(min.vals, function(x) {x@min}))\n      return(NLL)\n    } else\n      \n      fitted.parameters         <- map(min.vals, coef)\n    \n      formatted.responses$e0    <- unlist(map(fitted.parameters, 1))\n      formatted.responses$gamma <- unlist(map\n                                          (fitted.parameters, 2))\n      \n      return(formatted.responses)\n  }\n  \n  # Format responses for the objective function\n  format.response <- function(response.df) {\n    HIT               <- response.df$ECCENTRICITY[response.df$HIT == 1]\n    FA                <- response.df$ECCENTRICITY[response.df$MISS == 1]\n    CR                <- response.df$ECCENTRICITY[response.df$CORRECTREJECTION == 1]\n    MISS              <- response.df$ECCENTRICITY[response.df$MISS == 1]\n    \n    return(list(HIT = HIT, FA = FA, CR = CR, MISS = MISS))\n  }\n  \n  # Objective function\n  f.NLL <- function(d0, e0, b, gamma, data) {\n    HIT <- data$HIT\n    CR <- data$CR\n    FA <- data$FA\n    MISS <- data$MISS\n    \n    f <-\n      Vectorize(curry::partial(f.dprime.eccentricity, list(\n        d0 = d0,\n        e0 = e0,\n        b = b,\n        gamma = gamma\n      )))\n    \n    nll.cr = sum(pnorm(1 / 2 * f(CR), log = T))\n    nll.hit = sum(pnorm(1 / 2 * f(HIT), log = T))\n    nll.miss = sum(pnorm(-1 / 2 * f(MISS), log = T))\n    nll.fa = sum(pnorm(-1 / 2 * f(FA), log = T))\n\n    return(-sum(nll.cr, nll.hit, nll.miss, nll.fa))\n  }\n  \n  # Dprime as a function of eccentricity.\n  f.dprime.eccentricity <- function(x, d0, e0, b, gamma = 0) {\n    dprime <- d0 * e0 ^ b / (e0 ^ b + x ^ b) - gamma\n  }\n  \n  optim.b_g <- mle2(b.NLL, start = list(b = mean(formatted.responses$b)), method=\"L-BFGS-B\", lower = c(b = .5), upper = c(b = 10), control = list(trace = 4))\n  \n  fitted.psychometrics <- b.NLL(coef(optim.b_g), FALSE) %>% get_threshold(.)\n  return(fitted.psychometrics)\n  #save(file = '~/Dropbox/Calen/Dropbox/image.rdata', fitted.psychometrics)\n}\n\nfits <- lapply(list('vertical','horizontal', 'bowtie', 'spot'), FUN = function(x) simple.fit(x))\n\nfits.frame <- map(fits, function(x) {b.NLL(coef(x))})\n\nb.NLL(coef(optim.b_g), FALSE) %>% mutate(gamma = 0) %>% map(., get_threshold)",
    "created" : 1525704545661.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "82|44|89|2|\n92|45|112|2|\n",
    "hash" : "1077268213",
    "id" : "376D472B",
    "lastKnownWriteTime" : 1526360974,
    "last_content_update" : 1525716948807,
    "path" : "~/Dropbox/Calen/Work/occluding/detection_model_analysis/_human/simple_fit.R",
    "project_path" : null,
    "properties" : {
        "docOutlineVisible" : "1",
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}